# Enclosed is (part 2 of) the source for a mini-VI which I wrote when I
# first got the ST, to make things easier for my own development.  Although
# it is somewhat minimal in capabilities, it does have a fairly good
# implementation of the 'u' (undo) and '.' (repeat) commands.  I have
# much more interesting things to work on these days, so I am unlikely
# to provide any support.  It has worked well for 6 months, and since
# no alternatives have appeared on the net (other than VIX, which is
# too different for me), I figure it might be useful.
#      ...Tim Thompson...ihnp4!twitch!tjt...
#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#        main.c
#        misccmds.c
#        normal.c
#        stevie.h
#        window.c
# This archive created: Sun Jun 28 13:18:51 1987
export PATH; PATH=/bin:$PATH
if test -f 'main.c'
then
        echo shar: will not over-write existing file "'main.c'"
else
cat << \SHAR_EOF > 'main.c'
/*
 * STEVIE - ST Editor for VI Enthusiasts   ...Tim Thompson...twitch!tjt...
 */

#include <stdio.h>
#include <ctype.h>
#include "stevie.h"

#ifdef ATARI
#include <osbind.h>
#endif

#define NULL 0

int Rows;                /* Number of Rows and Columns */
int Columns;                /* in the current window. */

char *Realscreen;        /* What's currently on the screen, a single */
                        /* array of size Rows*Columns. */
char *Nextscreen;        /* What's to be put on the screen. */

char *Filename = NULL;        /* Current file name */

char *Filemem;                /* The contents of the file, as a single array. */

char *Filemax;                /* Pointer to the end of allocated space for */
                        /* Filemem. (It points to the first byte AFTER */
                        /* the allocated space.) */

char *Fileend;                /* Pointer to the end of the file in Filemem. */
                        /* (It points to the byte AFTER the last byte.) */

char *Topchar;                /* Pointer to the byte in Filemem which is */
                        /* in the upper left corner of the screen. */

char *Botchar;                /* Pointer to the byte in Filemem which is */
                        /* just off the bottom of the screen. */

char *Curschar;                /* Pointer to byte in Filemem at which the */
                        /* cursor is currently placed. */

int Cursrow, Curscol;        /* Current position of cursor */

int Cursvcol;                /* Current virtual column, the column number of */
                        /* the file's actual line, as opposed to the */
                        /* column number we're at on the screen.  This */
                        /* makes a difference on lines that span more */
                        /* than one screen line. */

int State = NORMAL;        /* This is the current state of the command */
                        /* interpreter. */

int Prenum = 0;                /* The (optional) number before a command. */

char *Insstart;                /* This is where the latest insert/append */
                        /* mode started. */

int Changed = 0;        /* Set to 1 if something in the file has been */
                        /* changed and not written out. */

int Debug = 0;

int Binary = 0;                /* Set to 1 if the file should be read and written */
                        /* in binary mode (no cr-lf translation). */

char Redobuff[1024];        /* Each command should stuff characters into this */
                        /* buffer that will re-execute itself. */

char Undobuff[1024];        /* Each command should stuff characters into this */
                        /* buffer that will undo its effects. */

char Insbuff[1024];        /* Each insertion gets stuffed into this buffer. */

char *Uncurschar = NULL;/* Curschar is restored to this before undoing. */

int Ninsert = 0;        /* Number of characters in the current insertion. */
int Undelchars = 0;        /* Number of characters to delete, when undoing. */
char *Insptr = NULL;

main(argc,argv)
int argc;
char **argv;
{
        int mode = 8;

        while ( argc>1 && argv[1][0] == '-' ) {
                switch (argv[1][1]) {
                case 'x':
                        mode = 16;
                        break;
                case 'o':
                        mode = 8;
                        break;
                case 'd':
                        Debug = 1;
                        break;
                case 'b':
                        Binary = 1;
                        break;
                }
                argc--;
                argv++;
        }

        if ( argc <= 1 ) {
                fprintf(stderr,"usage: stevie {file}\n");
                exit(1);
        }

        Filename = strsave(argv[1]);

        windinit();

        /* Make sure Rows/Columns are big enough */
        if ( Rows < 3 || Columns < 16 ) {
                fprintf(stderr,"Rows=%d Columns=%d not big enough!\n",
                        Rows,Columns);
                windexit(0);
        }

        switch ( mode ) {
        case 8:
                octchars();
                break;
        case 16:
                hexchars();
                break;
        }

        screenalloc();
        filealloc();

        screenclear();

        Fileend = Filemem;
        if ( readfile(Filename,Fileend,0) )
                filemess("[New File]");
        Topchar = Curschar = Filemem;

        updatescreen();
        
        edit();

        windexit(0);
}

/*
 * filetonext()
 *
 * Based on the current value of Topchar, transfer a screenfull of
 * stuff from Filemem to Nextscreen, and update Botchar.
 */

filetonext()
{
        int row, col;
        char *screenp = Nextscreen;
        char *memp = Topchar;
        char *endscreen;
        char *nextrow;
        char extra[16];
        int nextra = 0;
        int c;
        int n;

        /* The number of rows shown is Rows-1. */
        /* The last line is the status/command line. */
        endscreen = &screenp[(Rows-1)*Columns];

        row = col = 0;
        while ( screenp < endscreen && memp < Fileend ) {

                /* Get the next character to put on the screen. */

                /* The 'extra' array contains the extra stuff that is */
                /* inserted to represent special characters (tabs, and */
                /* other non-printable stuff.  The order in the 'extra' */
                /* array is reversed. */

                if ( nextra > 0 )
                        c = extra[--nextra];
                else {
                        c = (unsigned)(0xff & (*memp++));
                        /* when getting a character from the file, we */
                        /* may have to turn it into something else on */
                        /* the way to putting it into 'Nextscreen'. */
                        if ( c == '\t' ) {
                                strcpy(extra,"        ");
                                /* tab amount depends on current column */
                                nextra = (7 - col%8);
                                c = ' ';
                        }
                        else if ( (n=chars[c].ch_size) > 1 ) {
                                char *p;
                                nextra = 0;
                                p = chars[c].ch_str;
                                /* copy 'ch-str'ing into 'extra' in reverse */
                                while ( n > 1 )
                                        extra[nextra++] = p[--n];
                                c = p[0];
                        }
                }

                if ( c == '\n' ) {
                        row++;
                        /* get pointer to start of next row */
                        nextrow = &Nextscreen[row*Columns];
                        /* blank out the rest of this row */
                        while ( screenp != nextrow )
                                *screenp++ = ' ';
                        col = 0;
                        continue;
                }
                /* store the character in Nextscreen */
                if ( col >= Columns ) {
                        row++;
                        col = 0;
                }
                *screenp++ = c;
                col++;
        }
        /* make sure the rest of the screen is blank */
        while ( screenp < endscreen )
                *screenp++ = ' ';
        /* put '~'s on rows that aren't part of the file. */
        if ( col != 0 )
                row++;
        while ( row < Rows ) {
                Nextscreen[row*Columns] = '~';
                row++;
        }
        Botchar = memp;
}

/*
 * nexttoscreen
 *
 * Transfer the contents of Nextscreen to the screen, using Realscreen
 * to avoid unnecessary output.
 */

nexttoscreen()
{
        char *np = Nextscreen;
        char *rp = Realscreen;
        char *endscreen;
        char nc;
        int row = 0, col = 0;
        int gorow = -1, gocol = -1;

        endscreen = &np[(Rows-1)*Columns];

        for ( ; np < endscreen ; np++,rp++ ) {
                /* If desired screen (contents of Nextscreen) does not */
                /* match what's really there, put it there. */
                if ( (nc=(*np)) != (*rp) ) {
                        *rp = nc;
                        /* if we are positioned at the right place, */
                        /* we don't have to use windgoto(). */
                        if ( ! (gorow == row && gocol == col) )
                                windgoto(gorow=row,gocol=col);
                        windputc(nc);
                        gocol++;
                }
                if ( ++col >= Columns ) {
                        col = 0;
                        row++;
                }
        }
        windrefresh();
}

updatescreen()
{
        filetonext();
        nexttoscreen();
}

screenclear()
{
        int n;

        windclear();
        /* blank out the stored screens */
        for ( n=Rows*Columns-1; n>=0; n-- ) {
                Realscreen[n] = ' ';
                Nextscreen[n] = ' ';
        }
}

filealloc()
{
        if ( (Filemem=malloc((unsigned)FILELENG)) == NULL ) {
                fprintf(stderr,"Unable to allocate %d bytes for file memory!\n",
                        FILELENG);
                exit(1);
        }
        Filemax = Filemem + FILELENG;
}

screenalloc()
{
        Realscreen = malloc((unsigned)(Rows*Columns));
        Nextscreen = malloc((unsigned)(Rows*Columns));
}

readfile(fname,fromp,nochangename)
char *fname;
char *fromp;
int nochangename;        /* if 1, don't change the Filename */
{
#ifdef ATARI
        static char currdisk = 0;
        char fbuff[128];
        int c1, c2;
#endif
        FILE *f;
        char buff[128];
        char *p;
        int c, n;
        int unprint = 0;

#ifdef ATARI
        if ( currdisk == 0 )
                currdisk = 'a' + Dgetdrv();

        /* If a drive is specified, it is used from then */
        /* on as the default drive. */
        c1 = tolower(*fname);
        c2 = *(fname+1);
        if ( c2 == ':' && c1>='a' && c1<='z' )
                currdisk = c1;
        else {
                /* if no drive is specified, use the default one. */
                sprintf(fbuff,"%c:\\%s",toupper(currdisk),fname);
                fname = fbuff;
        }
#endif
        if ( ! nochangename )
                Filename = strsave(fname);

#ifdef ATARI
        if ( (f=fopen(fname,Binary?"br":"r")) == NULL ) {
#else
        if ( (f=fopen(fname,"r")) == NULL ) {
#endif
                Fileend = Filemem;
                return(1);
        }

        for ( n=0; (c=getc(f)) != EOF; n++ ) {
                if ( ! (isprint(c)||isspace(c)) )
                        unprint++;
                if ( fromp >= Filemax ) {
                        fprintf(stderr,"File too long (limit is %d)!\n",FILELENG);
                        exit(1);
                }
                /* Insert the char at the current point by shifting
                /* everything down. */
                for ( p=Fileend; p>fromp; p-- )
                        *p = *(p-1);
                *fromp++ = c;
                if ( Fileend < fromp )
                        Fileend = fromp;
        }
        if ( ! Binary && unprint > 0 ) {
                sprintf(buff,"%d unprintable chars!  Perhaps binary mode (-b) should be used?",unprint);
                message(buff);
                sleep(2);
        }
        if ( unprint > 0 )
                p = "\"%s\" %d characters (%d un-printable)  (Press 'H' for help)";
        else
                p = "\"%s\" %d characters  (Press 'H' for help)";
        sprintf(buff,p,fname,n,unprint);
        message(buff);
        fclose(f);
        return(0);
}

static char getcbuff[1024];
static char *getcnext = NULL;

stuffin(s)
char *s;
{
        if ( getcnext == NULL ) {
                strcpy(getcbuff,s);
                getcnext = getcbuff;
        }
        else
                strcat(getcbuff,s);
}

addtobuff(s,c1,c2,c3,c4,c5,c6)
char *s;
char c1, c2, c3, c4, c5, c6;
{
        char *p = s;
        if ( (*p++ = c1) == '\0' )
                return;
        if ( (*p++ = c2) == '\0' )
                return;
        if ( (*p++ = c3) == '\0' )
                return;
        if ( (*p++ = c4) == '\0' )
                return;
        if ( (*p++ = c5) == '\0' )
                return;
        if ( (*p++ = c6) == '\0' )
                return;
}

vgetc()
{
        if ( getcnext != NULL ) {
                int nextc = *getcnext++;
                if ( *getcnext == '\0' ) {
                        *getcbuff = '\0';
                        getcnext = NULL;
                }
                return(nextc);
        }
        return(windgetc());
}

vpeekc()
{
        if ( getcnext != NULL )
                return(*getcnext);
        return(-1);
}

/*
 * anyinput
 *
 * Return non-zero if input is pending.
 */

anyinput()
{
        if ( getcnext != NULL )
                return(1);
        return(0);
}

#ifdef ATARI
sleep(n)
int n;
{
        int k;

        k = Tgettime();
        while ( Tgettime() <= k+n )
                ;
}
#endif
SHAR_EOF
fi # end of overwriting check
if test -f 'misccmds.c'
then
        echo shar: will not over-write existing file "'misccmds.c'"
else
cat << \SHAR_EOF > 'misccmds.c'
/*
 * STevie - ST editor for VI enthusiasts.    ...Tim Thompson...twitch!tjt...
 */

#include <stdio.h>
#include <ctype.h>
#include "stevie.h"

/*
 * opencmd
 *
 * Add a blank line below the current line.
 */

opencmd()
{
        /* get to the end of the current line */ 
        while ( Curschar<Fileend && (*Curschar) != '\n' )
                Curschar++;
        /* Try to handle a file that doesn't end with a newline */
        if ( Curschar >= Fileend )
                Curschar = Fileend-1;
        /* Add the blank line */
        appchar('\n');
}

issepchar(c)
char c;
{
        if ( strchr(WORDSEP,c) != NULL )
                return(1);
        return(0);
}

cntlines(pbegin,pend)
char *pbegin, *pend;
{
        int lnum = 1;
        char *p;

        for ( p=pbegin; p<pend; ) {
                if ( *p++ == '\n' )
                        lnum++;
        }
        return(lnum);
}

fileinfo()
{
        char buff[128];

        sprintf(buff,"\"%s\"%s line %d of %d",
                Filename,
                Changed?" [Modified]":"",
                cntlines(Filemem,Curschar),
                cntlines(Filemem,Fileend)-1);
        message(buff);
}

gotoline(n)
int n;
{
        char *p;

        if ( n == 0 ) {
                if ( (p=prevline(Fileend)) != NULL )
                        Curschar = p;
        }
        else {
                /* Start at the top of the file and go down 'n'-1 lines */
                Curschar = Filemem;
                while ( --n > 0 ) {
                        if ( (p=nextline(Curschar)) == NULL )
                                break;
                        Curschar = p;
                }
        }
        Topchar = Curschar;
        for ( n=0; n<Rows/2; n++ ) {
                if ( (p=prevline(Topchar)) == NULL )
                        break;
                Topchar = p;
        }
        updatescreen();
}

char *Savedline = NULL;
int Savednum = 0;

/*
 * yankline
 *
 * Save a copy of the current line(s) for later 'p'lacing.
 */

yankline(n)
{
        char *savep, *p, *q;
        int leng, k;

        if ( Savedline != NULL )
                free(Savedline);
        savep = Curschar;
        /* go to the beginning of the current line. */
        beginline();
        /* compute length of line */
        for ( p=Curschar,leng=0; ; p++ ) {
                if ( *p == '\n' ) {
                        /* keep going until we've seen 'n' lines */
                        if ( --n <= 0 )
                                break;
                }
                leng++;
        }
        /* save a copy of it */
        Savedline = malloc((unsigned)(leng+2));
        for ( p=Curschar,q=Savedline,k=0; k<leng; k++ )
                *q++ = *p++;
        /* get the final newline */
        *q++ = *p;
        *q = '\0';
        Curschar = savep;
        Savednum = leng+1;
}

/*
 * putline
 *
 * If there is a currently saved line(s), 'p'ut it.
 * If k==1, 'P'ut the line (i.e. above instead of below.
 */

putline(k)
int k;
{
        char *p;
        int n;

        if ( Savedline == NULL )
                return;
        message("Inserting saved stuff...");
        if ( k == 0 ) {
                /* get to the end of the current line */
                while ( Curschar<Fileend && *Curschar != '\n' )
                        Curschar++;
        }
        else
                beginline();
        /* append or insert the characters of the saved line */
        for ( p=Savedline,n=0; n<Savednum; p++,n++ ) {
                if ( k == 0 )
                        appchar(*p);
                else
                        inschar(*p);
        }
        /* We want to end up at the beginning of the line. */
        while ( n-->1 )
                Curschar--;
        if ( k == 1 )
                Curschar--;
        beginline();
        message("");
        updatescreen();
}

inschar(c)
int c;
{
        register char *p;

        /* Move everything in the file over to make */
        /* room for the new char. */
        if ( ! canincrease(1) )
                return;

        for ( p=Fileend; p>Curschar; p-- ) {
                *p = *(p-1);
        }
        *Curschar++ = c;
        Fileend++;
        CHANGED;
}

insstr(s)
char *s;
{
        register char *p;
        int k, n = strlen(s);

        /* Move everything in the file over to make */
        /* room for the new string. */
        if ( ! canincrease(n) )
                return;

        for ( p=Fileend-1+n; p>Curschar; p-- ) {
                *p = *(p-n);
        }
        for ( k=0; k<n; k++ )
                *Curschar++ = *s++;
        Fileend += n;
        CHANGED;
}

appchar(c)
int c;
{
        char *p, *endp;

        /* Move everything in the file over to make */
        /* room for the new char. */
        if ( ! canincrease(1) )
                return;

        endp = Curschar+1;
        for ( p=Fileend; p>endp; p-- ) {
                *p = *(p-1);
        }
        *(++Curschar) = c;
        Fileend++;
        CHANGED;
}

canincrease(n)
int n;
{
        if ( (Fileend+n) >= Filemax ) {
                message("Can't add anything, file is too big!");
                State = NORMAL;
                return(0);
        }
        return(1);
}

#define NULL 0

delchar()
{
        char *p;

        /* Check for degenerate case; there's nothing in the file. */
        if ( Filemem == Fileend )
                return;
        /* Delete the character at Curschar by shifting everything */
        /* in the file down. */
        for ( p=Curschar+1; p<Fileend; p++ )
                *(p-1) = *p;
        /* If we just took off the last character of a non-blank line, */
        /* we don't want to end up positioned at the newline. */
        if ( *Curschar=='\n' && Curschar>Filemem && *(Curschar-1)!='\n' )
                Curschar--;
        Fileend--;
        CHANGED;
}

delword(deltrailing)
int deltrailing;        /* 1 if trailing white space should be removed. */
{
        int c = *Curschar;
        char *p = Undobuff;

        /* The Undo string is an 'i'nsert of the word we're deleting. */
        *p++ = 'i';
        /* If we're positioned on a word separator... */
        if ( issepchar(c) && ! isspace(c) ) {
                /* If we're on a non-space separator, remove */
                /* the separators and any following space. */
                while ( issepchar(c) && ! isspace(c) ) {
                        /* Add the deleted character to the Undobuff */
                        *p++ = *Curschar;
                        delchar();
                        c = *Curschar;
                }
        }
        else {        /* we're positioned in the middle of a word */
                int endofline = 0;
                while ( ! issepchar(*Curschar) && *Curschar != '\n' ) {
                        /* If the next char is a newline, we note */
                        /* that fact here, because delchar() won't */
                        /* position us there afterword. */
                        if ( *(Curschar+1) == '\n' )
                                endofline = 1;
                        /* Add the deleted character to the Undobuff */
                        *p++ = *Curschar;
                        delchar();
                        if ( endofline )
                                break;
                }
        }
        if ( deltrailing ) {
                /* remove any trailing white space */
                while ( isspace(*Curschar) && *Curschar != '\n' ) {
                        /* Add the deleted character to the Undobuff */
                        *p++ = *Curschar;
                        delchar();
                }
        }
        *p++ = '\033';
        *p = '\0';
}

delline(nlines)
{
        int nchars;
        char *p, *q;

        /* If we're not at the beginning of the line, get there. */
        if ( *Curschar != '\n' ) {
                /* back up to the previous newline (or the beginning */
                /* of the file. */
                while ( Curschar > Filemem ) {
                        if ( *Curschar == '\n' ) {
                                Curschar++;
                                break;
                        }
                        Curschar--;
                }
        }
        message("Deleting...");
        while ( nlines-- > 0 ) {
                /* Count the characters in the line */
                for ( nchars=1,p=Curschar; p<Fileend&&*p!='\n'; p++,nchars++ )
                        ;
                /* Delete the characters of the line */
                /* by moving everything else in the file down. */
                q = Curschar;
                p = Curschar+nchars;
                while ( p<Fileend )
                        *q++ = *p++;
                Fileend -= nchars;
                CHANGED;

                /* If we delete the last line in the file, back up */
                if ( Curschar >= Fileend ) {
                        if ( (Curschar=prevline(Curschar)) == NULL )
                                Curschar = Filemem;
                        /* and don't try to delete any more lines */
                        break;
                }
        }
        message("");
}

char *strchr(s,c)
char *s;
int c;
{
        do {
                if ( *s == c )
                        return(s);
        } while (*s++);
        return(NULL);
}
SHAR_EOF
fi # end of overwriting check
if test -f 'normal.c'
then
        echo shar: will not over-write existing file "'normal.c'"
else
cat << \SHAR_EOF > 'normal.c'
/*
 * STevie - ST editor for VI enthusiasts.    ...Tim Thompson...twitch!tjt...
 */

#include <ctype.h>
#include "stevie.h"

/*
 * normal
 *
 * Execute a command in normal mode.
 */

normal(c)
int c;
{
        char *p, *q;
        int nchar, n;

        switch(c){
        case 'H':
                help();
                /* fall through purposely */
        case '\014':
                screenclear();
                updatescreen();
                break;
        case 04:
                /* control-d */
                if ( ! onedown(10) )
                        beep();
                break;
        case  025:
                /* control-u */
                if ( ! oneup(10) )
                        beep();
                break;
        case 06:
                /* control-f */
                if ( ! onedown(Rows) )
                        beep();
                break;
        case 02:
                /* control-b */
                if ( ! oneup(Rows) )
                        beep();
                break;
        case '\007':
                fileinfo();
                break;
        case 'G':
                gotoline(Prenum);
                break;
        case 'l':
                if ( ! oneright() )
                        beep();
                break;
        case 'h':
                if ( ! oneleft() )
                        beep();
                break;
        case 'k':
                if ( ! oneup(1) )
                        beep();
                break;
        case 'j':
                if ( ! onedown(1) )
                        beep();
                break;
        case 'b':
                /* If we're on the first character of a word, force */
                /* an initial backup. */
                if ( ! issepchar(*Curschar) && Curschar>Filemem
                        && issepchar(*(Curschar-1)) )
                        Curschar--;

                if ( ! issepchar(*Curschar) ) {
                        /* If we start in the middle of a word, back */
                        /* up until we hit a separator. */
                        while ( Curschar>Filemem && !issepchar(*Curschar))
                                Curschar--;
                        if ( issepchar(*Curschar) )
                                Curschar++;
                }
                else {
                        /* back up past all separators. */
                        while ( Curschar>Filemem && issepchar(*Curschar))
                                Curschar--;
                        /* back up past all non-separators. */
                        while (Curschar>Filemem && !issepchar(*Curschar)){
                                Curschar--;
                        }
                        if ( issepchar(*Curschar) )
                                Curschar++;
                }
                break;
        case 'w':
                if ( issepchar(*Curschar) ) {
                        /* If we're on a separator, we advance to */
                        /* the next non-separator char. */
                        while ( (p=Curschar+1) < Fileend ) {
                                Curschar = p;
                                if ( ! issepchar(*Curschar) )
                                        break;
                        }
                }
                else {
                        /* If we're in the middle of a word, we */
                        /* advance to the next word-separator. */
                        while ( (p=Curschar+1) < Fileend ) {
                                Curschar = p;
                                if ( issepchar(*Curschar) )
                                        break;
                        }
                        /* Now go past any trailing white space */
                        while (isspace(*Curschar) && (Curschar+1)<Fileend)
                                Curschar++;
                }
                break;
        case '$':
                while ( oneright() )
                        ;
                break;
        case '0':
        case '^':
                beginline();
                break;
        case 'x':
                /* Can't do it if we're on a blank line.  (Actually it */
                /* does work, but we want to match the real 'vi'...) */
                if ( *Curschar == '\n' )
                        beep();
                else {
                        addtobuff(Redobuff,'x',NULL);
                        /* To undo it, we insert the same character back. */
                        resetundo();
                        addtobuff(Undobuff,'i',*Curschar,'\033',NULL);
                        Uncurschar = Curschar;
                        delchar();
                        updatescreen();
                }
                break;
        case 'a':
                /* Works just like an 'i'nsert on the next character. */
                if ( Curschar < (Fileend-1) )
                        Curschar++;
                resetundo();
                startinsert("a");
                break;
        case 'i':
                resetundo();
                startinsert("i");
                break;
        case 'o':
                opencmd();
                updatescreen();
                resetundo();
                startinsert("o");
                break;
        case 'd':
                nchar = vgetc();
                n = (Prenum==0?1:Prenum);
                switch(nchar){
                case 'd':
                        sprintf(Redobuff,"%ddd",n);
                        /* addtobuff(Redobuff,'d','d',NULL); */
                        beginline();
                        resetundo();
                        Uncurschar = Curschar;
                        yankline(n);
                        delline(n);
                        beginline();
                        updatescreen();
                        /* If we have backed xyzzy, then we deleted the */
                        /* last line(s) in the file. */
                        if ( Curschar < Uncurschar ) {
                                Uncurschar = Curschar;
                                nchar = 'p';
                        }
                        else
                                nchar = 'P';
                        addtobuff(Undobuff,nchar,NULL);
                        break;
                case 'w':
                        addtobuff(Redobuff,'d','w',NULL);
                        resetundo();
                        delword(1);
                        Uncurschar = Curschar;
                        updatescreen();
                        break;
                }
                break;
        case 'c':
                nchar = vgetc();
                switch(nchar){
                case 'c':
                        resetundo();
                        /* Go to the beginning of the line */
                        beginline();
                        yankline(1);
                        /* delete everything but the newline */
                        while ( *Curschar != '\n' )
                                delchar();
                        startinsert("cc");
                        updatescreen();
                        break;
                case 'w':
                        resetundo();
                        delword(0);
                        startinsert("cw");
                        updatescreen();
                        break;
                }
                break;
        case 'y':
                nchar = vgetc();
                switch(nchar){
                case 'y':
                        yankline(Prenum==0?1:Prenum);
                        break;
                default:
                        beep();
                }
                break;
        case '>':
                nchar = vgetc();
                n = (Prenum==0?1:Prenum);
                switch(nchar){
                case '>':
                        tabinout(0,n);
                        updatescreen();
                        break;
                default:
                        beep();
                }
                break;
        case '<':
                nchar = vgetc();
                n = (Prenum==0?1:Prenum);
                switch(nchar){
                case '<':
                        tabinout(1,n);
                        updatescreen();
                        break;
                default:
                        beep();
                }
                break;
        case '?':
        case '/':
        case ':':
                readcmdline(c);
                break;
        case 'n':
                repsearch();
                break;
        case 'C':
        case 'D':
                p = Curschar;
                while ( Curschar >= p )
                        delchar();
                updatescreen();
                resetundo();        /* This should really go above the */
                                /* delchars above, and the undobuff should */
                                /* be constructed by them. */
                if ( c == 'C' ) {
                        Curschar++;
                        startinsert("C");
                }
                break;
        case 'r':
                nchar = vgetc();
                resetundo();
                if ( nchar=='\n' || (!Binary && nchar=='\r') ) {
                        /* Replacing a char with a newline breaks the */
                        /* line in two, and is special. */
                        nchar = '\n';        /* convert \r to \n */
                        /* Save stuff necessary to undo it, by joining */
                        Uncurschar = Curschar-1;
                        addtobuff(Undobuff,'J','i',*Curschar,'\033',NULL);
                        /* Change current character. */
                        *Curschar = nchar;
                        /* We don't want to end up on the '\n' */
                        if ( Curschar > Filemem )
                                Curschar--;
                        else if (Curschar < Fileend )
                                Curschar++;
                }
                else {
                        /* Replacing with a normal character */
                        addtobuff(Undobuff,'r',*Curschar,NULL);
                        Uncurschar = Curschar;
                        /* Change current character. */
                        *Curschar = nchar;
                }
                /* Save stuff necessary to redo it */
                addtobuff(Redobuff,'r',nchar,NULL);
                updatescreen();
                break;
        case 'p':
                putline(0);
                break;
        case 'P':
                putline(1);
                break;
        case 'J':
                for ( p=Curschar; *p!= '\n' && p<(Fileend-1) ; p++ )
                        ;
                if ( p >= (Fileend-1) ) {
                        beep();
                        break;
                }
                Curschar = p;
                delchar();
                resetundo();
                Uncurschar = Curschar;
                addtobuff(Undobuff,'i','\n','\033',NULL);
                addtobuff(Redobuff,'J',NULL);
                updatescreen();
                break;
        case '.':
                stuffin(Redobuff);
                break;
        case 'u':
                if ( Uncurschar != NULL && *Undobuff != '\0' ) {
                        Curschar = Uncurschar;
                        stuffin(Undobuff);
                        *Undobuff = '\0';
                }
                if ( Undelchars > 0 ) {
                        Curschar = Uncurschar;
                        /* construct the next Undobuff and Redobuff, which */
                        /* will re-insert the characters we're deleting. */
                        p = Undobuff;
                        q = Redobuff;
                        *p++ = *q++ = 'i';
                        while ( Undelchars-- > 0 ) {
                                *p++ = *q++ = *Curschar;
                                delchar();
                        }
                        /* Finish constructing Uncursbuff, and Uncurschar */
                        /* is left unchanged. */
                        *p++ = *q++ = '\033';
                        *p = *q = '\0';
                        /* Undelchars has been reset to 0 */
                        updatescreen();
                }
                break;
        default:
                beep();
                break;
        }
}

/*
 * tabinout(inout,num)
 *
 * If inout==0, add a tab to the begining of the next num lines.
 * If inout==1, delete a tab from the begining of the next num lines.
 */

tabinout(inout,num)
{
        int ntodo = num;
        char *savecurs, *p;

        beginline();
        savecurs = Curschar;
        while ( ntodo-- > 0 ) {
                beginline();
                if ( inout == 0 )
                        inschar('\t');
                else {
                        if ( *Curschar == '\t' )
                                delchar();
                }
                if ( ntodo > 0 ) {
                        if ( (p=nextline(Curschar)) != NULL )
                                Curschar = p;
                        else
                                break;
                }
        }
        /* We want to end up where we started */
        Curschar = savecurs;
        updatescreen();
        /* Construct re-do and un-do stuff */
        sprintf(Redobuff,"%d%s",num,inout==0?">>":"<<");
        resetundo();
        Uncurschar = savecurs;
        sprintf(Undobuff,"%d%s",num,inout==0?"<<":">>");
}

startinsert(initstr)
char *initstr;
{
        char *p, c;

        Insstart = Curschar;
        Ninsert = 0;
        Insptr = Insbuff;
        for (p=initstr; (c=(*p++))!='\0'; )
                *Insptr++ = c;
        State = INSERT;
        windrefresh();
}

resetundo()
{
        Undelchars = 0;
        *Undobuff = '\0';
        Uncurschar = NULL;
}
SHAR_EOF
fi # end of overwriting check
if test -f 'stevie.h'
then
        echo shar: will not over-write existing file "'stevie.h'"
else
cat << \SHAR_EOF > 'stevie.h'
/*
 * STevie - ST editor for VI enthusiasts.    ...Tim Thompson...twitch!tjt...
 */

/* One (and only 1) of the following 3 defines should be uncommented. */
/* Most of the code is machine-independent.  Most of the machine- */
/* dependent stuff is in window.c */

#define ATARI                1        /* For the Atari 520 ST */
/*#define UNIXPC        1        /* The AT&T UNIX PC (console) */
/*#define TCAP                1        /* For termcap-based terminals */

#define FILELENG 64000
#define NORMAL 0
#define CMDLINE 1
#define INSERT 2
#define APPEND 3
#define FORWARD 4
#define BACKWARD 5
#define WORDSEP " \t\n()[]{},;:'\"-="

#define CHANGED Changed=1
#define UNCHANGED Changed=0

#ifndef NULL
#define NULL 0
#endif

struct charinfo {
        char ch_size;
        char *ch_str;
};

extern struct charinfo chars[];

extern int State;
extern int Rows;
extern int Columns;
extern char *Realscreen;
extern char *Nextscreen;
extern char *Filename;
extern char *Filemem;
extern char *Filemax;
extern char *Fileend;
extern char *Topchar;
extern char *Botchar;
extern char *Curschar;
extern char *Insstart;
extern int Cursrow, Curscol, Cursvcol;
extern int Prenum;
extern int Debug;
extern int Changed;
extern int Binary;
extern char Redobuff[], Undobuff[], Insbuff[];
extern char *Uncurschar, *Insptr;
extern int Ninsert, Undelchars;

char *malloc(), *strchr(), *strsave(), *alloc(), *strcpy();

char *nextline(), *prevline(), *coladvance(), *ssearch();
char *fwdsearch(), *bcksearch();
SHAR_EOF
fi # end of overwriting check
if test -f 'window.c'
then
        echo shar: will not over-write existing file "'window.c'"
else
cat << \SHAR_EOF > 'window.c'
/*
 * STevie - ST editor for VI enthusiasts.    ...Tim Thompson...twitch!tjt...
 */

#include "stevie.h"
#include <stdio.h>

#ifdef ATARI
#include <osbind.h>
#define EscSeq(x) Cconout('\033');Cconout(x);
#endif
#ifdef UNIXPC
#include <sys/window.h>
#endif
#ifdef TCAP
#include <curses.h>
#endif

windinit()
{
#ifdef ATARI
        Columns=80;
        Rows=25;
        Cursconf(1,NULL);
#endif
#ifdef UNIXPC
        struct uwdata uw;
        
        winit();
        if ( ioctl(0,WIOCGETD,&uw) == -1
          && ioctl(1,WIOCGETD,&uw) == -1
          && ioctl(2,WIOCGETD,&uw) == -1 ) {
                fprintf(stderr,"*** ERROR *** Not a window!\n");
                windexit(1);
        }
        Columns = uw.uw_width / uw.uw_hs;
        Rows = uw.uw_height / uw.uw_vs;
        cbreak();
        nonl();
        noecho();
#endif
#ifdef TCAP
        char *getenv();
        char *p = getenv("TERM");

        initscr();
        Columns = 80;
        if ( strncmp(p,"vt52",4)==0 )
                Rows = 25;
        else
                Rows = 24;
        cbreak();
        nonl();
        noecho();
#endif
}

windgoto(r,c)
int r,c;
{
#ifdef UNIXPC
        printf("\033[%d;%dH",r+1,c+1);
#endif
#ifdef ATARI
        EscSeq('Y');
        Cconout(r+040);
        Cconout(c+040);
#endif
#ifdef TCAP
        move(r,c);
#endif
}

windexit(r)
int r;
{
#ifdef UNIXPC
        nocbreak();
        nl();
        echo();
        wexit();
#endif
#ifdef TCAP
        nocbreak();
        nl();
        echo();
        endwin();
#endif
        exit(r);
}

windclear()
{
#ifdef UNIXPC
        printf("\033[H\033[J");
#endif
#ifdef ATARI
        Cconws("\033H\033J");
#endif
#ifdef TCAP
        clear();
        refresh();
#endif
}

windgetc()
{
#ifdef ATARI
        return(Cnecin());
#else
        return(getchar());
#endif
}

windstr(s)
char *s;
{
#ifdef ATARI
        Cconws(s);
#endif
#ifdef UNIXPC
        printf("%s",s);
#endif
#ifdef TCAP
        addstr(s);
        refresh();
#endif
}

windputc(c)
int c;
{
#ifdef ATARI
        Cconout(c);
#endif
#ifdef UNIXPC
        putchar(c);
#endif
#ifdef TCAP
        addch(c);
#endif
}

windrefresh()
{
#ifdef TCAP
        refresh();
#endif
}

beep()
{
#ifdef ATARI
        Cconout('\007');
#else
        putchar('\007');
#endif
}
SHAR_EOF
fi # end of overwriting check
#        End of shell archive
exit 0